#version 430 core
#define M_PI 3.1415926535897932384626433832795
#define M_G 9.81

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D textureHdx;
layout(rgba32f, binding = 1) uniform image2D textureHdy;
layout(rgba32f, binding = 2) uniform image2D textureHdz;
layout(rgba32f, binding = 3) uniform image2D textureH0;
layout(rgba32f, binding = 4) uniform image2D textureH0inverse;

uniform int gridSize;
uniform int horizontalDimension;
uniform float time;

struct complex {
	float real;
	float im;
};

complex mul(complex c0, complex c1) {
	complex c;
	c.real = c0.real * c1.real - c0.im * c1.im;
	c.im = c0.real * c1.im + c0.im * c1.real;
	return c ;
}

complex add(complex c0, complex c1) {
	complex c ;
	c.real = c0.real + c1.real;
	c.im = c0.im + c1.im;
	return c;
}

complex conj(complex c) {
	complex c_conj = complex(c.real, -c.im);
	return c_conj;
}

void main()
{
	ivec2 pixel_pos = ivec2(gl_GlobalInvocationID.xy);
	vec2 x = pixel_pos - float(gridSize) / 2.0;

	vec2 k = x * 2.0 * M_PI / horizontalDimension;

	float mag = length(k);
	if (mag < 0.00001) {
		mag = 0.00001;
	}
	float w = sqrt(mag * M_G);

	vec2 h0 = imageLoad(textureH0, pixel_pos).rg;
	vec2 h0inverse = imageLoad(textureH0inverse, pixel_pos).rg;

	complex fourier_cmp = complex(h0.x, h0.y);
	complex fourier_cmp_conj = conj(complex(h0inverse.x, h0inverse.y));

	float cos_w_t = cos(w * time);
	float sin_w_t = sin(w * time);

	complex exp_iwt = complex(cos_w_t, sin_w_t);
	complex exp_iwt_inv = complex(cos_w_t, -sin_w_t);

	complex h_k_t_dy = add(mul(fourier_cmp, exp_iwt), mul(fourier_cmp_conj, exp_iwt_inv));

	complex dx = complex(0.0, -k.x / mag);
	complex h_k_t_dx = mul(dx, h_k_t_dy);

	complex dy = complex(0.0, -k.y / mag);
	complex h_k_t_dz = mul(dy, h_k_t_dy);

	imageStore(textureHdy, pixel_pos, vec4(h_k_t_dy.real, h_k_t_dy.im, 0, 1));
	
	imageStore(textureHdx, pixel_pos, vec4(h_k_t_dx.real, h_k_t_dx.im, 0, 1));
	
	imageStore(textureHdz, pixel_pos, vec4(h_k_t_dz.real, h_k_t_dz.im, 0, 1));
}